// Generated by Molecule 0.7.5
// Generated by Moleculec-Go 0.1.11

package xudt

import (
	"bytes"
	"errors"
	"strconv"
	"strings"
)

type ScriptVecBuilder struct {
	inner []Script
}

func (s *ScriptVecBuilder) Build() ScriptVec {
	itemCount := len(s.inner)

	b := new(bytes.Buffer)

	// Empty dyn vector, just return size's bytes
	if itemCount == 0 {
		b.Write(packNumber(Number(HeaderSizeUint)))
		return ScriptVec{inner: b.Bytes()}
	}

	// Calculate first offset then loop for rest items offsets
	totalSize := HeaderSizeUint * uint32(itemCount+1)
	offsets := make([]uint32, 0, itemCount)
	offsets = append(offsets, totalSize)
	for i := 1; i < itemCount; i++ {
		totalSize += uint32(len(s.inner[i-1].AsSlice()))
		offsets = append(offsets, offsets[i-1]+uint32(len(s.inner[i-1].AsSlice())))
	}
	totalSize += uint32(len(s.inner[itemCount-1].AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < itemCount; i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	for i := 0; i < itemCount; i++ {
		b.Write(s.inner[i].AsSlice())
	}

	return ScriptVec{inner: b.Bytes()}
}

func (s *ScriptVecBuilder) Set(v []Script) *ScriptVecBuilder {
	s.inner = v
	return s
}
func (s *ScriptVecBuilder) Push(v Script) *ScriptVecBuilder {
	s.inner = append(s.inner, v)
	return s
}
func (s *ScriptVecBuilder) Extend(iter []Script) *ScriptVecBuilder {
	for i := 0; i < len(iter); i++ {
		s.inner = append(s.inner, iter[i])
	}
	return s
}
func (s *ScriptVecBuilder) Replace(index uint, v Script) *Script {
	if uint(len(s.inner)) > index {
		a := s.inner[index]
		s.inner[index] = v
		return &a
	}
	return nil
}

func NewScriptVecBuilder() *ScriptVecBuilder {
	return &ScriptVecBuilder{[]Script{}}
}

type ScriptVec struct {
	inner []byte
}

func ScriptVecFromSliceUnchecked(slice []byte) *ScriptVec {
	return &ScriptVec{inner: slice}
}
func (s *ScriptVec) AsSlice() []byte {
	return s.inner
}

func ScriptVecDefault() ScriptVec {
	return *ScriptVecFromSliceUnchecked([]byte{4, 0, 0, 0})
}

func ScriptVecFromSlice(slice []byte, compatible bool) (*ScriptVec, error) {
	sliceLen := len(slice)

	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ScriptVec", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ScriptVec", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint {
		return &ScriptVec{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ScriptVec", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "ScriptVec", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ScriptVec", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}
	itemCount := uint32(offsetFirst)/HeaderSizeUint - 1

	offsets := make([]uint32, itemCount)

	for i := 0; i < int(itemCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}

	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			errMsg := strings.Join([]string{"OffsetsNotMatch", "ScriptVec"}, " ")
			return nil, errors.New(errMsg)
		}
	}

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 {
			start := offsets[i-1]
			end := offsets[i]
			_, err := ScriptFromSlice(slice[start:end], compatible)

			if err != nil {
				return nil, err
			}
		}
	}

	return &ScriptVec{inner: slice}, nil
}

func (s *ScriptVec) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *ScriptVec) ItemCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *ScriptVec) Len() uint {
	return s.ItemCount()
}
func (s *ScriptVec) IsEmpty() bool {
	return s.Len() == 0
}

// if *Script is nil, index is out of bounds
func (s *ScriptVec) Get(index uint) *Script {
	var b *Script
	if index < s.Len() {
		start_index := uint(HeaderSizeUint) * (1 + index)
		start := unpackNumber(s.inner[start_index:])

		if index == s.Len()-1 {
			b = ScriptFromSliceUnchecked(s.inner[start:])
		} else {
			end_index := start_index + uint(HeaderSizeUint)
			end := unpackNumber(s.inner[end_index:])
			b = ScriptFromSliceUnchecked(s.inner[start:end])
		}
	}
	return b
}

func (s *ScriptVec) AsBuilder() ScriptVecBuilder {
	size := s.ItemCount()
	t := NewScriptVecBuilder()
	for i := uint(0); i < size; i++ {
		t.Push(*s.Get(i))
	}
	return *t
}

type ScriptVecOptBuilder struct {
	isNone bool
	inner  ScriptVec
}

func NewScriptVecOptBuilder() *ScriptVecOptBuilder {
	return &ScriptVecOptBuilder{isNone: true, inner: ScriptVecDefault()}
}
func (s *ScriptVecOptBuilder) Set(v ScriptVec) *ScriptVecOptBuilder {
	s.isNone = false
	s.inner = v
	return s
}
func (s *ScriptVecOptBuilder) Build() ScriptVecOpt {
	var ret ScriptVecOpt
	if s.isNone {
		ret = ScriptVecOpt{inner: []byte{}}
	} else {
		ret = ScriptVecOpt{inner: s.inner.AsSlice()}
	}
	return ret
}

type ScriptVecOpt struct {
	inner []byte
}

func ScriptVecOptFromSliceUnchecked(slice []byte) *ScriptVecOpt {
	return &ScriptVecOpt{inner: slice}
}
func (s *ScriptVecOpt) AsSlice() []byte {
	return s.inner
}

func ScriptVecOptDefault() ScriptVecOpt {
	return *ScriptVecOptFromSliceUnchecked([]byte{})
}

func ScriptVecOptFromSlice(slice []byte, compatible bool) (*ScriptVecOpt, error) {
	if len(slice) == 0 {
		return &ScriptVecOpt{inner: slice}, nil
	}

	_, err := ScriptVecFromSlice(slice, compatible)
	if err != nil {
		return nil, err
	}
	return &ScriptVecOpt{inner: slice}, nil
}

func (s *ScriptVecOpt) IntoScriptVec() (*ScriptVec, error) {
	if s.IsNone() {
		return nil, errors.New("No data")
	}
	return ScriptVecFromSliceUnchecked(s.AsSlice()), nil
}
func (s *ScriptVecOpt) IsSome() bool {
	return len(s.inner) != 0
}
func (s *ScriptVecOpt) IsNone() bool {
	return len(s.inner) == 0
}
func (s *ScriptVecOpt) AsBuilder() ScriptVecOptBuilder {
	var ret = NewScriptVecOptBuilder()
	if s.IsSome() {
		ret.Set(*ScriptVecFromSliceUnchecked(s.AsSlice()))
	}
	return *ret
}

type XudtWitnessInputBuilder struct {
	owner_script       ScriptOpt
	owner_signature    BytesOpt
	raw_extension_data ScriptVecOpt
	extension_data     BytesVec
}

func (s *XudtWitnessInputBuilder) Build() XudtWitnessInput {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (4 + 1)
	offsets := make([]uint32, 0, 4)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.owner_script.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.owner_signature.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.raw_extension_data.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.extension_data.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.owner_script.AsSlice())
	b.Write(s.owner_signature.AsSlice())
	b.Write(s.raw_extension_data.AsSlice())
	b.Write(s.extension_data.AsSlice())
	return XudtWitnessInput{inner: b.Bytes()}
}

func (s *XudtWitnessInputBuilder) OwnerScript(v ScriptOpt) *XudtWitnessInputBuilder {
	s.owner_script = v
	return s
}

func (s *XudtWitnessInputBuilder) OwnerSignature(v BytesOpt) *XudtWitnessInputBuilder {
	s.owner_signature = v
	return s
}

func (s *XudtWitnessInputBuilder) RawExtensionData(v ScriptVecOpt) *XudtWitnessInputBuilder {
	s.raw_extension_data = v
	return s
}

func (s *XudtWitnessInputBuilder) ExtensionData(v BytesVec) *XudtWitnessInputBuilder {
	s.extension_data = v
	return s
}

func NewXudtWitnessInputBuilder() *XudtWitnessInputBuilder {
	return &XudtWitnessInputBuilder{owner_script: ScriptOptDefault(), owner_signature: BytesOptDefault(), raw_extension_data: ScriptVecOptDefault(), extension_data: BytesVecDefault()}
}

type XudtWitnessInput struct {
	inner []byte
}

func XudtWitnessInputFromSliceUnchecked(slice []byte) *XudtWitnessInput {
	return &XudtWitnessInput{inner: slice}
}
func (s *XudtWitnessInput) AsSlice() []byte {
	return s.inner
}

func XudtWitnessInputDefault() XudtWitnessInput {
	return *XudtWitnessInputFromSliceUnchecked([]byte{24, 0, 0, 0, 20, 0, 0, 0, 20, 0, 0, 0, 20, 0, 0, 0, 20, 0, 0, 0, 4, 0, 0, 0})
}

func XudtWitnessInputFromSlice(slice []byte, compatible bool) (*XudtWitnessInput, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "XudtWitnessInput", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "XudtWitnessInput", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "XudtWitnessInput", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "XudtWitnessInput", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "XudtWitnessInput", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 4 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 4 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = ScriptOptFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesOptFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = ScriptVecOptFromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesVecFromSlice(slice[offsets[3]:offsets[4]], compatible)
	if err != nil {
		return nil, err
	}

	return &XudtWitnessInput{inner: slice}, nil
}

func (s *XudtWitnessInput) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *XudtWitnessInput) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *XudtWitnessInput) Len() uint {
	return s.FieldCount()
}
func (s *XudtWitnessInput) IsEmpty() bool {
	return s.Len() == 0
}
func (s *XudtWitnessInput) CountExtraFields() uint {
	return s.FieldCount() - 4
}

func (s *XudtWitnessInput) HasExtraFields() bool {
	return 4 != s.FieldCount()
}

func (s *XudtWitnessInput) OwnerScript() *ScriptOpt {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return ScriptOptFromSliceUnchecked(s.inner[start:end])
}

func (s *XudtWitnessInput) OwnerSignature() *BytesOpt {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return BytesOptFromSliceUnchecked(s.inner[start:end])
}

func (s *XudtWitnessInput) RawExtensionData() *ScriptVecOpt {
	start := unpackNumber(s.inner[12:])
	end := unpackNumber(s.inner[16:])
	return ScriptVecOptFromSliceUnchecked(s.inner[start:end])
}

func (s *XudtWitnessInput) ExtensionData() *BytesVec {
	var ret *BytesVec
	start := unpackNumber(s.inner[16:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[20:])
		ret = BytesVecFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = BytesVecFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *XudtWitnessInput) AsBuilder() XudtWitnessInputBuilder {
	ret := NewXudtWitnessInputBuilder().OwnerScript(*s.OwnerScript()).OwnerSignature(*s.OwnerSignature()).RawExtensionData(*s.RawExtensionData()).ExtensionData(*s.ExtensionData())
	return *ret
}

type RCRuleBuilder struct {
	smt_root Byte32
	flags    Byte
}

func (s *RCRuleBuilder) Build() RCRule {
	b := new(bytes.Buffer)
	b.Write(s.smt_root.AsSlice())
	b.Write(s.flags.AsSlice())
	return RCRule{inner: b.Bytes()}
}

func (s *RCRuleBuilder) SmtRoot(v Byte32) *RCRuleBuilder {
	s.smt_root = v
	return s
}

func (s *RCRuleBuilder) Flags(v Byte) *RCRuleBuilder {
	s.flags = v
	return s
}

func NewRCRuleBuilder() *RCRuleBuilder {
	return &RCRuleBuilder{smt_root: Byte32Default(), flags: ByteDefault()}
}

type RCRule struct {
	inner []byte
}

func RCRuleFromSliceUnchecked(slice []byte) *RCRule {
	return &RCRule{inner: slice}
}
func (s *RCRule) AsSlice() []byte {
	return s.inner
}

func RCRuleDefault() RCRule {
	return *RCRuleFromSliceUnchecked([]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func RCRuleFromSlice(slice []byte, _compatible bool) (*RCRule, error) {
	sliceLen := len(slice)
	if sliceLen != 33 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "RCRule", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(33)}, " ")
		return nil, errors.New(errMsg)
	}
	return &RCRule{inner: slice}, nil
}

func (s *RCRule) SmtRoot() *Byte32 {
	ret := Byte32FromSliceUnchecked(s.inner[0:32])
	return ret
}

func (s *RCRule) Flags() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[32:33])
	return ret
}

func (s *RCRule) AsBuilder() RCRuleBuilder {
	ret := NewRCRuleBuilder().SmtRoot(*s.SmtRoot()).Flags(*s.Flags())
	return *ret
}

type RCCellVecBuilder struct {
	inner []Byte32
}

func (s *RCCellVecBuilder) Build() RCCellVec {
	size := packNumber(Number(len(s.inner)))

	b := new(bytes.Buffer)

	b.Write(size)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}

	sb := RCCellVec{inner: b.Bytes()}

	return sb
}

func (s *RCCellVecBuilder) Set(v []Byte32) *RCCellVecBuilder {
	s.inner = v
	return s
}
func (s *RCCellVecBuilder) Push(v Byte32) *RCCellVecBuilder {
	s.inner = append(s.inner, v)
	return s
}
func (s *RCCellVecBuilder) Extend(iter []Byte32) *RCCellVecBuilder {
	for i := 0; i < len(iter); i++ {
		s.inner = append(s.inner, iter[i])
	}
	return s
}
func (s *RCCellVecBuilder) Replace(index uint, v Byte32) *Byte32 {
	if uint(len(s.inner)) > index {
		a := s.inner[index]
		s.inner[index] = v
		return &a
	}
	return nil
}

func NewRCCellVecBuilder() *RCCellVecBuilder {
	return &RCCellVecBuilder{[]Byte32{}}
}

type RCCellVec struct {
	inner []byte
}

func RCCellVecFromSliceUnchecked(slice []byte) *RCCellVec {
	return &RCCellVec{inner: slice}
}
func (s *RCCellVec) AsSlice() []byte {
	return s.inner
}

func RCCellVecDefault() RCCellVec {
	return *RCCellVecFromSliceUnchecked([]byte{0, 0, 0, 0})
}

func RCCellVecFromSlice(slice []byte, _compatible bool) (*RCCellVec, error) {
	sliceLen := len(slice)
	if sliceLen < int(HeaderSizeUint) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "RCCellVec", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}
	itemCount := unpackNumber(slice)
	if itemCount == 0 {
		if sliceLen != int(HeaderSizeUint) {
			errMsg := strings.Join([]string{"TotalSizeNotMatch", "RCCellVec", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(HeaderSizeUint))}, " ")
			return nil, errors.New(errMsg)
		}
		return &RCCellVec{inner: slice}, nil
	}
	totalSize := int(HeaderSizeUint) + int(32*itemCount)
	if sliceLen != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "RCCellVec", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}
	return &RCCellVec{inner: slice}, nil
}

func (s *RCCellVec) TotalSize() uint {
	return uint(HeaderSizeUint) + 32*s.ItemCount()
}
func (s *RCCellVec) ItemCount() uint {
	number := uint(unpackNumber(s.inner))
	return number
}
func (s *RCCellVec) Len() uint {
	return s.ItemCount()
}
func (s *RCCellVec) IsEmpty() bool {
	return s.Len() == 0
}

// if *Byte32 is nil, index is out of bounds
func (s *RCCellVec) Get(index uint) *Byte32 {
	var re *Byte32
	if index < s.Len() {
		start := uint(HeaderSizeUint) + 32*index
		end := start + 32
		re = Byte32FromSliceUnchecked(s.inner[start:end])
	}
	return re
}

func (s *RCCellVec) AsBuilder() RCCellVecBuilder {
	size := s.ItemCount()
	t := NewRCCellVecBuilder()
	for i := uint(0); i < size; i++ {
		t.Push(*s.Get(i))
	}
	return *t
}

type RCDataBuilder struct {
	inner RCDataUnion
}

func NewRCDataBuilder() *RCDataBuilder {
	v := RCDataDefault()
	return &RCDataBuilder{inner: *v.ToUnion()}
}
func (s *RCDataBuilder) Set(v RCDataUnion) *RCDataBuilder {
	s.inner = v
	return s
}
func (s *RCDataBuilder) Build() RCData {
	b := new(bytes.Buffer)
	b.Write(packNumber(s.inner.itemID))
	b.Write(s.inner.AsSlice())

	return RCData{inner: b.Bytes()}
}

type RCData struct {
	inner []byte
}

func RCDataFromSliceUnchecked(slice []byte) *RCData {
	return &RCData{inner: slice}
}
func (s *RCData) AsSlice() []byte {
	return s.inner
}

func RCDataDefault() RCData {
	return *RCDataFromSliceUnchecked([]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

type RCDataUnion struct {
	itemID Number
	inner  []byte
}

func (s *RCDataUnion) AsSlice() []byte {
	return s.inner
}
func (s *RCDataUnion) ItemID() Number {
	return s.itemID
}

func RCDataUnionFromRCRule(v RCRule) RCDataUnion {
	return RCDataUnion{itemID: 0, inner: v.AsSlice()}
}

func (s *RCDataUnion) IntoRCRule() *RCRule {
	switch s.ItemID() {
	case 0:
		return RCRuleFromSliceUnchecked(s.AsSlice())
	default:
		errMsg := strings.Join([]string{"invalid item_id: expect 0, found", strconv.Itoa(int(s.ItemID()))}, " ")
		panic(errMsg)
	}
}

func RCDataUnionFromRCCellVec(v RCCellVec) RCDataUnion {
	return RCDataUnion{itemID: 1, inner: v.AsSlice()}
}

func (s *RCDataUnion) IntoRCCellVec() *RCCellVec {
	switch s.ItemID() {
	case 1:
		return RCCellVecFromSliceUnchecked(s.AsSlice())
	default:
		errMsg := strings.Join([]string{"invalid item_id: expect 1, found", strconv.Itoa(int(s.ItemID()))}, " ")
		panic(errMsg)
	}
}

func (s *RCDataUnion) ItemName() string {
	switch s.itemID {

	case 0:
		return "RCRule"

	case 1:
		return "RCCellVec"

	default:
		panic("invalid data: RCDataUnion")
	}
}

func (s *RCData) ToUnion() *RCDataUnion {
	switch s.ItemID() {

	case 0:
		return &RCDataUnion{itemID: 0, inner: s.inner[HeaderSizeUint:]}

	case 1:
		return &RCDataUnion{itemID: 1, inner: s.inner[HeaderSizeUint:]}

	default:
		panic("invalid data: RCData")
	}
}

func RCDataFromSlice(slice []byte, compatible bool) (*RCData, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "RCData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}
	itemID := unpackNumber(slice)
	innerSlice := slice[HeaderSizeUint:]

	switch itemID {

	case 0:
		_, err := RCRuleFromSlice(innerSlice, compatible)
		if err != nil {
			return nil, err
		}

	case 1:
		_, err := RCCellVecFromSlice(innerSlice, compatible)
		if err != nil {
			return nil, err
		}

	default:
		return nil, errors.New("UnknownItem, RCData")
	}
	return &RCData{inner: slice}, nil
}

func (s *RCData) ItemID() Number {
	return unpackNumber(s.inner)
}
func (s *RCData) AsBuilder() RCDataBuilder {
	return *NewRCDataBuilder().Set(*s.ToUnion())
}

type SmtProofBuilder struct {
	inner []Byte
}

func (s *SmtProofBuilder) Build() SmtProof {
	size := packNumber(Number(len(s.inner)))

	b := new(bytes.Buffer)

	b.Write(size)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}

	sb := SmtProof{inner: b.Bytes()}

	return sb
}

func (s *SmtProofBuilder) Set(v []Byte) *SmtProofBuilder {
	s.inner = v
	return s
}
func (s *SmtProofBuilder) Push(v Byte) *SmtProofBuilder {
	s.inner = append(s.inner, v)
	return s
}
func (s *SmtProofBuilder) Extend(iter []Byte) *SmtProofBuilder {
	for i := 0; i < len(iter); i++ {
		s.inner = append(s.inner, iter[i])
	}
	return s
}
func (s *SmtProofBuilder) Replace(index uint, v Byte) *Byte {
	if uint(len(s.inner)) > index {
		a := s.inner[index]
		s.inner[index] = v
		return &a
	}
	return nil
}

func NewSmtProofBuilder() *SmtProofBuilder {
	return &SmtProofBuilder{[]Byte{}}
}

type SmtProof struct {
	inner []byte
}

func SmtProofFromSliceUnchecked(slice []byte) *SmtProof {
	return &SmtProof{inner: slice}
}
func (s *SmtProof) AsSlice() []byte {
	return s.inner
}

func SmtProofDefault() SmtProof {
	return *SmtProofFromSliceUnchecked([]byte{0, 0, 0, 0})
}

func SmtProofFromSlice(slice []byte, _compatible bool) (*SmtProof, error) {
	sliceLen := len(slice)
	if sliceLen < int(HeaderSizeUint) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "SmtProof", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}
	itemCount := unpackNumber(slice)
	if itemCount == 0 {
		if sliceLen != int(HeaderSizeUint) {
			errMsg := strings.Join([]string{"TotalSizeNotMatch", "SmtProof", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(HeaderSizeUint))}, " ")
			return nil, errors.New(errMsg)
		}
		return &SmtProof{inner: slice}, nil
	}
	totalSize := int(HeaderSizeUint) + int(1*itemCount)
	if sliceLen != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "SmtProof", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}
	return &SmtProof{inner: slice}, nil
}

func (s *SmtProof) TotalSize() uint {
	return uint(HeaderSizeUint) + 1*s.ItemCount()
}
func (s *SmtProof) ItemCount() uint {
	number := uint(unpackNumber(s.inner))
	return number
}
func (s *SmtProof) Len() uint {
	return s.ItemCount()
}
func (s *SmtProof) IsEmpty() bool {
	return s.Len() == 0
}

// if *Byte is nil, index is out of bounds
func (s *SmtProof) Get(index uint) *Byte {
	var re *Byte
	if index < s.Len() {
		start := uint(HeaderSizeUint) + 1*index
		end := start + 1
		re = ByteFromSliceUnchecked(s.inner[start:end])
	}
	return re
}

func (s *SmtProof) RawData() []byte {
	return s.inner[HeaderSizeUint:]
}

func (s *SmtProof) AsBuilder() SmtProofBuilder {
	size := s.ItemCount()
	t := NewSmtProofBuilder()
	for i := uint(0); i < size; i++ {
		t.Push(*s.Get(i))
	}
	return *t
}

type SmtProofEntryBuilder struct {
	mask  Byte
	proof SmtProof
}

func (s *SmtProofEntryBuilder) Build() SmtProofEntry {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (2 + 1)
	offsets := make([]uint32, 0, 2)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.mask.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.proof.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.mask.AsSlice())
	b.Write(s.proof.AsSlice())
	return SmtProofEntry{inner: b.Bytes()}
}

func (s *SmtProofEntryBuilder) Mask(v Byte) *SmtProofEntryBuilder {
	s.mask = v
	return s
}

func (s *SmtProofEntryBuilder) Proof(v SmtProof) *SmtProofEntryBuilder {
	s.proof = v
	return s
}

func NewSmtProofEntryBuilder() *SmtProofEntryBuilder {
	return &SmtProofEntryBuilder{mask: ByteDefault(), proof: SmtProofDefault()}
}

type SmtProofEntry struct {
	inner []byte
}

func SmtProofEntryFromSliceUnchecked(slice []byte) *SmtProofEntry {
	return &SmtProofEntry{inner: slice}
}
func (s *SmtProofEntry) AsSlice() []byte {
	return s.inner
}

func SmtProofEntryDefault() SmtProofEntry {
	return *SmtProofEntryFromSliceUnchecked([]byte{17, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0})
}

func SmtProofEntryFromSlice(slice []byte, compatible bool) (*SmtProofEntry, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "SmtProofEntry", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "SmtProofEntry", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "SmtProofEntry", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "SmtProofEntry", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "SmtProofEntry", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 2 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 2 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = ByteFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = SmtProofFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	return &SmtProofEntry{inner: slice}, nil
}

func (s *SmtProofEntry) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *SmtProofEntry) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *SmtProofEntry) Len() uint {
	return s.FieldCount()
}
func (s *SmtProofEntry) IsEmpty() bool {
	return s.Len() == 0
}
func (s *SmtProofEntry) CountExtraFields() uint {
	return s.FieldCount() - 2
}

func (s *SmtProofEntry) HasExtraFields() bool {
	return 2 != s.FieldCount()
}

func (s *SmtProofEntry) Mask() *Byte {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return ByteFromSliceUnchecked(s.inner[start:end])
}

func (s *SmtProofEntry) Proof() *SmtProof {
	var ret *SmtProof
	start := unpackNumber(s.inner[8:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[12:])
		ret = SmtProofFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = SmtProofFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *SmtProofEntry) AsBuilder() SmtProofEntryBuilder {
	ret := NewSmtProofEntryBuilder().Mask(*s.Mask()).Proof(*s.Proof())
	return *ret
}

type SmtProofEntryVecBuilder struct {
	inner []SmtProofEntry
}

func (s *SmtProofEntryVecBuilder) Build() SmtProofEntryVec {
	itemCount := len(s.inner)

	b := new(bytes.Buffer)

	// Empty dyn vector, just return size's bytes
	if itemCount == 0 {
		b.Write(packNumber(Number(HeaderSizeUint)))
		return SmtProofEntryVec{inner: b.Bytes()}
	}

	// Calculate first offset then loop for rest items offsets
	totalSize := HeaderSizeUint * uint32(itemCount+1)
	offsets := make([]uint32, 0, itemCount)
	offsets = append(offsets, totalSize)
	for i := 1; i < itemCount; i++ {
		totalSize += uint32(len(s.inner[i-1].AsSlice()))
		offsets = append(offsets, offsets[i-1]+uint32(len(s.inner[i-1].AsSlice())))
	}
	totalSize += uint32(len(s.inner[itemCount-1].AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < itemCount; i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	for i := 0; i < itemCount; i++ {
		b.Write(s.inner[i].AsSlice())
	}

	return SmtProofEntryVec{inner: b.Bytes()}
}

func (s *SmtProofEntryVecBuilder) Set(v []SmtProofEntry) *SmtProofEntryVecBuilder {
	s.inner = v
	return s
}
func (s *SmtProofEntryVecBuilder) Push(v SmtProofEntry) *SmtProofEntryVecBuilder {
	s.inner = append(s.inner, v)
	return s
}
func (s *SmtProofEntryVecBuilder) Extend(iter []SmtProofEntry) *SmtProofEntryVecBuilder {
	for i := 0; i < len(iter); i++ {
		s.inner = append(s.inner, iter[i])
	}
	return s
}
func (s *SmtProofEntryVecBuilder) Replace(index uint, v SmtProofEntry) *SmtProofEntry {
	if uint(len(s.inner)) > index {
		a := s.inner[index]
		s.inner[index] = v
		return &a
	}
	return nil
}

func NewSmtProofEntryVecBuilder() *SmtProofEntryVecBuilder {
	return &SmtProofEntryVecBuilder{[]SmtProofEntry{}}
}

type SmtProofEntryVec struct {
	inner []byte
}

func SmtProofEntryVecFromSliceUnchecked(slice []byte) *SmtProofEntryVec {
	return &SmtProofEntryVec{inner: slice}
}
func (s *SmtProofEntryVec) AsSlice() []byte {
	return s.inner
}

func SmtProofEntryVecDefault() SmtProofEntryVec {
	return *SmtProofEntryVecFromSliceUnchecked([]byte{4, 0, 0, 0})
}

func SmtProofEntryVecFromSlice(slice []byte, compatible bool) (*SmtProofEntryVec, error) {
	sliceLen := len(slice)

	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "SmtProofEntryVec", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "SmtProofEntryVec", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint {
		return &SmtProofEntryVec{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "SmtProofEntryVec", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "SmtProofEntryVec", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "SmtProofEntryVec", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}
	itemCount := uint32(offsetFirst)/HeaderSizeUint - 1

	offsets := make([]uint32, itemCount)

	for i := 0; i < int(itemCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}

	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			errMsg := strings.Join([]string{"OffsetsNotMatch", "SmtProofEntryVec"}, " ")
			return nil, errors.New(errMsg)
		}
	}

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 {
			start := offsets[i-1]
			end := offsets[i]
			_, err := SmtProofEntryFromSlice(slice[start:end], compatible)

			if err != nil {
				return nil, err
			}
		}
	}

	return &SmtProofEntryVec{inner: slice}, nil
}

func (s *SmtProofEntryVec) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *SmtProofEntryVec) ItemCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *SmtProofEntryVec) Len() uint {
	return s.ItemCount()
}
func (s *SmtProofEntryVec) IsEmpty() bool {
	return s.Len() == 0
}

// if *SmtProofEntry is nil, index is out of bounds
func (s *SmtProofEntryVec) Get(index uint) *SmtProofEntry {
	var b *SmtProofEntry
	if index < s.Len() {
		start_index := uint(HeaderSizeUint) * (1 + index)
		start := unpackNumber(s.inner[start_index:])

		if index == s.Len()-1 {
			b = SmtProofEntryFromSliceUnchecked(s.inner[start:])
		} else {
			end_index := start_index + uint(HeaderSizeUint)
			end := unpackNumber(s.inner[end_index:])
			b = SmtProofEntryFromSliceUnchecked(s.inner[start:end])
		}
	}
	return b
}

func (s *SmtProofEntryVec) AsBuilder() SmtProofEntryVecBuilder {
	size := s.ItemCount()
	t := NewSmtProofEntryVecBuilder()
	for i := uint(0); i < size; i++ {
		t.Push(*s.Get(i))
	}
	return *t
}

type SmtUpdateItemBuilder struct {
	key           Byte32
	packed_values Byte
}

func (s *SmtUpdateItemBuilder) Build() SmtUpdateItem {
	b := new(bytes.Buffer)
	b.Write(s.key.AsSlice())
	b.Write(s.packed_values.AsSlice())
	return SmtUpdateItem{inner: b.Bytes()}
}

func (s *SmtUpdateItemBuilder) Key(v Byte32) *SmtUpdateItemBuilder {
	s.key = v
	return s
}

func (s *SmtUpdateItemBuilder) PackedValues(v Byte) *SmtUpdateItemBuilder {
	s.packed_values = v
	return s
}

func NewSmtUpdateItemBuilder() *SmtUpdateItemBuilder {
	return &SmtUpdateItemBuilder{key: Byte32Default(), packed_values: ByteDefault()}
}

type SmtUpdateItem struct {
	inner []byte
}

func SmtUpdateItemFromSliceUnchecked(slice []byte) *SmtUpdateItem {
	return &SmtUpdateItem{inner: slice}
}
func (s *SmtUpdateItem) AsSlice() []byte {
	return s.inner
}

func SmtUpdateItemDefault() SmtUpdateItem {
	return *SmtUpdateItemFromSliceUnchecked([]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func SmtUpdateItemFromSlice(slice []byte, _compatible bool) (*SmtUpdateItem, error) {
	sliceLen := len(slice)
	if sliceLen != 33 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "SmtUpdateItem", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(33)}, " ")
		return nil, errors.New(errMsg)
	}
	return &SmtUpdateItem{inner: slice}, nil
}

func (s *SmtUpdateItem) Key() *Byte32 {
	ret := Byte32FromSliceUnchecked(s.inner[0:32])
	return ret
}

func (s *SmtUpdateItem) PackedValues() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[32:33])
	return ret
}

func (s *SmtUpdateItem) AsBuilder() SmtUpdateItemBuilder {
	ret := NewSmtUpdateItemBuilder().Key(*s.Key()).PackedValues(*s.PackedValues())
	return *ret
}

type SmtUpdateItemVecBuilder struct {
	inner []SmtUpdateItem
}

func (s *SmtUpdateItemVecBuilder) Build() SmtUpdateItemVec {
	size := packNumber(Number(len(s.inner)))

	b := new(bytes.Buffer)

	b.Write(size)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}

	sb := SmtUpdateItemVec{inner: b.Bytes()}

	return sb
}

func (s *SmtUpdateItemVecBuilder) Set(v []SmtUpdateItem) *SmtUpdateItemVecBuilder {
	s.inner = v
	return s
}
func (s *SmtUpdateItemVecBuilder) Push(v SmtUpdateItem) *SmtUpdateItemVecBuilder {
	s.inner = append(s.inner, v)
	return s
}
func (s *SmtUpdateItemVecBuilder) Extend(iter []SmtUpdateItem) *SmtUpdateItemVecBuilder {
	for i := 0; i < len(iter); i++ {
		s.inner = append(s.inner, iter[i])
	}
	return s
}
func (s *SmtUpdateItemVecBuilder) Replace(index uint, v SmtUpdateItem) *SmtUpdateItem {
	if uint(len(s.inner)) > index {
		a := s.inner[index]
		s.inner[index] = v
		return &a
	}
	return nil
}

func NewSmtUpdateItemVecBuilder() *SmtUpdateItemVecBuilder {
	return &SmtUpdateItemVecBuilder{[]SmtUpdateItem{}}
}

type SmtUpdateItemVec struct {
	inner []byte
}

func SmtUpdateItemVecFromSliceUnchecked(slice []byte) *SmtUpdateItemVec {
	return &SmtUpdateItemVec{inner: slice}
}
func (s *SmtUpdateItemVec) AsSlice() []byte {
	return s.inner
}

func SmtUpdateItemVecDefault() SmtUpdateItemVec {
	return *SmtUpdateItemVecFromSliceUnchecked([]byte{0, 0, 0, 0})
}

func SmtUpdateItemVecFromSlice(slice []byte, _compatible bool) (*SmtUpdateItemVec, error) {
	sliceLen := len(slice)
	if sliceLen < int(HeaderSizeUint) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "SmtUpdateItemVec", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}
	itemCount := unpackNumber(slice)
	if itemCount == 0 {
		if sliceLen != int(HeaderSizeUint) {
			errMsg := strings.Join([]string{"TotalSizeNotMatch", "SmtUpdateItemVec", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(HeaderSizeUint))}, " ")
			return nil, errors.New(errMsg)
		}
		return &SmtUpdateItemVec{inner: slice}, nil
	}
	totalSize := int(HeaderSizeUint) + int(33*itemCount)
	if sliceLen != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "SmtUpdateItemVec", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}
	return &SmtUpdateItemVec{inner: slice}, nil
}

func (s *SmtUpdateItemVec) TotalSize() uint {
	return uint(HeaderSizeUint) + 33*s.ItemCount()
}
func (s *SmtUpdateItemVec) ItemCount() uint {
	number := uint(unpackNumber(s.inner))
	return number
}
func (s *SmtUpdateItemVec) Len() uint {
	return s.ItemCount()
}
func (s *SmtUpdateItemVec) IsEmpty() bool {
	return s.Len() == 0
}

// if *SmtUpdateItem is nil, index is out of bounds
func (s *SmtUpdateItemVec) Get(index uint) *SmtUpdateItem {
	var re *SmtUpdateItem
	if index < s.Len() {
		start := uint(HeaderSizeUint) + 33*index
		end := start + 33
		re = SmtUpdateItemFromSliceUnchecked(s.inner[start:end])
	}
	return re
}

func (s *SmtUpdateItemVec) AsBuilder() SmtUpdateItemVecBuilder {
	size := s.ItemCount()
	t := NewSmtUpdateItemVecBuilder()
	for i := uint(0); i < size; i++ {
		t.Push(*s.Get(i))
	}
	return *t
}

type SmtUpdateActionBuilder struct {
	updates SmtUpdateItemVec
	proof   SmtProof
}

func (s *SmtUpdateActionBuilder) Build() SmtUpdateAction {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (2 + 1)
	offsets := make([]uint32, 0, 2)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.updates.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.proof.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.updates.AsSlice())
	b.Write(s.proof.AsSlice())
	return SmtUpdateAction{inner: b.Bytes()}
}

func (s *SmtUpdateActionBuilder) Updates(v SmtUpdateItemVec) *SmtUpdateActionBuilder {
	s.updates = v
	return s
}

func (s *SmtUpdateActionBuilder) Proof(v SmtProof) *SmtUpdateActionBuilder {
	s.proof = v
	return s
}

func NewSmtUpdateActionBuilder() *SmtUpdateActionBuilder {
	return &SmtUpdateActionBuilder{updates: SmtUpdateItemVecDefault(), proof: SmtProofDefault()}
}

type SmtUpdateAction struct {
	inner []byte
}

func SmtUpdateActionFromSliceUnchecked(slice []byte) *SmtUpdateAction {
	return &SmtUpdateAction{inner: slice}
}
func (s *SmtUpdateAction) AsSlice() []byte {
	return s.inner
}

func SmtUpdateActionDefault() SmtUpdateAction {
	return *SmtUpdateActionFromSliceUnchecked([]byte{20, 0, 0, 0, 12, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func SmtUpdateActionFromSlice(slice []byte, compatible bool) (*SmtUpdateAction, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "SmtUpdateAction", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "SmtUpdateAction", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "SmtUpdateAction", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "SmtUpdateAction", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "SmtUpdateAction", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 2 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 2 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = SmtUpdateItemVecFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = SmtProofFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	return &SmtUpdateAction{inner: slice}, nil
}

func (s *SmtUpdateAction) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *SmtUpdateAction) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *SmtUpdateAction) Len() uint {
	return s.FieldCount()
}
func (s *SmtUpdateAction) IsEmpty() bool {
	return s.Len() == 0
}
func (s *SmtUpdateAction) CountExtraFields() uint {
	return s.FieldCount() - 2
}

func (s *SmtUpdateAction) HasExtraFields() bool {
	return 2 != s.FieldCount()
}

func (s *SmtUpdateAction) Updates() *SmtUpdateItemVec {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return SmtUpdateItemVecFromSliceUnchecked(s.inner[start:end])
}

func (s *SmtUpdateAction) Proof() *SmtProof {
	var ret *SmtProof
	start := unpackNumber(s.inner[8:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[12:])
		ret = SmtProofFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = SmtProofFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *SmtUpdateAction) AsBuilder() SmtUpdateActionBuilder {
	ret := NewSmtUpdateActionBuilder().Updates(*s.Updates()).Proof(*s.Proof())
	return *ret
}

type XudtDataBuilder struct {
	lock Bytes
	data BytesVec
}

func (s *XudtDataBuilder) Build() XudtData {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (2 + 1)
	offsets := make([]uint32, 0, 2)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.lock.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.data.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.lock.AsSlice())
	b.Write(s.data.AsSlice())
	return XudtData{inner: b.Bytes()}
}

func (s *XudtDataBuilder) Lock(v Bytes) *XudtDataBuilder {
	s.lock = v
	return s
}

func (s *XudtDataBuilder) Data(v BytesVec) *XudtDataBuilder {
	s.data = v
	return s
}

func NewXudtDataBuilder() *XudtDataBuilder {
	return &XudtDataBuilder{lock: BytesDefault(), data: BytesVecDefault()}
}

type XudtData struct {
	inner []byte
}

func XudtDataFromSliceUnchecked(slice []byte) *XudtData {
	return &XudtData{inner: slice}
}
func (s *XudtData) AsSlice() []byte {
	return s.inner
}

func XudtDataDefault() XudtData {
	return *XudtDataFromSliceUnchecked([]byte{20, 0, 0, 0, 12, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0})
}

func XudtDataFromSlice(slice []byte, compatible bool) (*XudtData, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "XudtData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "XudtData", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "XudtData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "XudtData", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "XudtData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 2 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 2 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = BytesFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesVecFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	return &XudtData{inner: slice}, nil
}

func (s *XudtData) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *XudtData) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *XudtData) Len() uint {
	return s.FieldCount()
}
func (s *XudtData) IsEmpty() bool {
	return s.Len() == 0
}
func (s *XudtData) CountExtraFields() uint {
	return s.FieldCount() - 2
}

func (s *XudtData) HasExtraFields() bool {
	return 2 != s.FieldCount()
}

func (s *XudtData) Lock() *Bytes {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return BytesFromSliceUnchecked(s.inner[start:end])
}

func (s *XudtData) Data() *BytesVec {
	var ret *BytesVec
	start := unpackNumber(s.inner[8:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[12:])
		ret = BytesVecFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = BytesVecFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *XudtData) AsBuilder() XudtDataBuilder {
	ret := NewXudtDataBuilder().Lock(*s.Lock()).Data(*s.Data())
	return *ret
}
